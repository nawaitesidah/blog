<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width, minimal-ui, initial-scale=1, viewport-fit=cover">
        <title>Postgres’ Dead Tuples</title>
        <link rel="icon" type="image/png" href="assets/images/favicon.png">
        <link href="assets/css/main.css" rel="stylesheet">
    </head>
    <body>
        <h1 id="postgres-dead-tuples">Postgres’ Dead Tuples</h1>
<p><em>2024-10-24</em></p>
<p>When we delete a tuple, Postgres still keep the tuple in the disk, only marking it as deleted. This is called dead tuples.</p>
<p>Dead tuples uses extra space, so when there’s many deletes (and updates!), even without any new inserts, postgres will use more and more disk space. </p>
<p>The question become</p>
<blockquote>
<h3 id="why-is-there-a-need-for-dead-tuple-why-not-just-actually-delete-it-from-the-disk">Why is there a need for dead tuple? Why not just actually delete it from the disk?</h3>
</blockquote>
<p>There’s two reasons:</p>
<ol>
<li><p>Physical storage layout</p>
<ul>
<li><p>Postgres does not physically store a tuple into a file in the disk, but postgres stores a group of tuples together into a file, which is called page.</p>
<p>A page is 8KB in size, so there could be multiple tuples stored together in a page.</p>
</li>
<li><p>Due to this, postgres can’t delete just one row. Otherwise postgres would need to rewrite a whole page excluding the deleted rows, which will be inefficient.</p>
<p>PS. This is actually what VACUUM FULL does, rewriting pages without dead tuples.</p>
</li>
</ul>
</li>
<li><p>MVCC (multiversion concurrency control)</p>
<ul>
<li><p>Postgres uses MVCC, it keeps multiple version of a row, so that a transaction can return a consistent result.</p>
<p>Example: When using repeatable read isolation level, even if other transaction has deleted a row and committed, the repeatable read transaction will still see the data, exactly the same way as when it started the transaction.</p>
</li>
<li><p>In order to do that, postgres need to keep the deleted tuples, just for the existing transactions to read.</p>
</li>
<li><p><strong>This is the case for update too!</strong></p>
<p>Example: In a repeatable read transaction, we’ll read the same value as long as we’re still in that transaction, regardless of what other transactions did to that tuple.</p>
<p>This is possible because postgres do not update the tuple directly on the page. But postgres handle update by doing delete on the old tuple (marked as dead tuple) and insert the updated rows as new tuples.</p>
</li>
</ul>
</li>
</ol>
<p>The next question will be:</p>
<blockquote>
<h3 id="why-postgres-cant-just-reuse-the-dead-tuple-space-when-inserting-a-new-tuple">Why postgres can’t just reuse the dead tuple space when inserting a new tuple?</h3>
</blockquote>
<p>If postgres already know that there’s a dead tuple, why not just reuse the space, and write the new tuple over the dead tuple?</p>
<p>Unfortunately, on writing the new tuple postgres has no direct way to know whether a tuple can still be accessed by any other transaction or not.</p>
<p>Consider this, a tuple was deleted an hour ago, and now there’s a new tuple to be written. On write, we have to be sure there’s no transaction that can still read this row e.g. repeatable read transaction started before the tuple was deleted.</p>
<blockquote>
<h3 id="how-can-postgres-make-sure-that-the-dead-tuple-is-not-used-by-any-other-active-transactions">How can postgres make sure that the dead tuple is not used by any other active transactions?</h3>
</blockquote>
<p>Without checking for all other transactions, there’s no way to be sure.</p>
<p>But if postgres checks for all other transactions on every writes, then it’ll be inefficient</p>
<blockquote>
<h3 id="then-how-to-actually-reuse-the-disk-space-of-dead-tuples">Then how to actually reuse the disk space of dead tuples?</h3>
</blockquote>
<p>Here’s where VACUUM is used. Vacuum goes through every page to find the dead tuples, then it checks whether there’s any active transaction that still can access the dead tuples or no. Then it’ll rewrite a new page without the dead tuples.</p>
<p>In contrast, VACUUM FULL rewrites the whole pages and excluding the dead tuples. So the new page will only have live tuples, this frees the disk space from the dead tuple.</p>

    </body>
</html>